* Notes from start of term

I believe the main changes relevant to the paper that I made to obj-C that we
may want to port to C++ are the following:

1. One vs Multiple MDDs being settable as a general setting based on variable
   overlap - I believe in C++ this is written specifically for a couple files,
   but this is instead letting you set either one MDD that every constraint
   uses, one MDD for each individual constraint, or combining constraints into
   shared MDDs based on variable overlap.
   
2. Splitting and filtering in one pass or two - Having a setting to either, when
   doing the top-down pass, split every layer then filter every layer OR split a
   single layer then filter that layer repeated for every layer.
      
3. How to select which node to attempt to split next.  When splitting a layer,
   each node is given some priority.  Nodes with highest priority are chosen to
   split first.
   
4. How to select which candidate is given its own, new node next.  When
   candidates are obtained from examining nodes, each candidate is given a
   priority value.  Once all of a group of candidates are obtained, these
   candidates are selected to split into a new node based on these priority
   values.
   
5. A setting where when a node is being examined for splitting (i.e. creating
   candidates) if some approximate equivalence function is used or if only exact
   equivalence is used.
6. When creating candidates for split, how many nodes are examined before these
   splits occur. e.g. do we only look at one node, obtain its candidates, and
   then split them? Do we look at every single node on the layer, obtain its
   candidates, and then split them? Do we look at some percentage or set number
   of nodes for this?
7. When performing a split, do we look at every constraint's
   state/approximateEquivalence value at once or do we target in on a single
   constraint, split for it, and then move onto the lower priority constraints?
   (So every constraint would have its own priority rank given)
8. When we split, if we have extra room on the layer, do we do any followup
   splits? This could be by doing approximate equivalence first, then exact
   equivalence, or by doing the regular splits, and then just arbitrarily
   splitting individual edges until it hits width.

These all act as settings that can be given either on the type of constraint
(i.e. if approximate equivalence, what function it uses) or as a general MDD
setting (e.g. set a variable as ~splitAllLayersBeforeFiltering~).

There may have been some other changes between the two that are possibly worth
looking into? But those are the main changes I made with respect to the upcoming
paper so that we can have settings to customize the MDD model to be 'better'.

I believe these are the targets in obj-C that currently make use of those
settings: ~AmongNurseSwift, AllIntervalSwift, carSeqMDDSwift, workForceMDDSwift~

Finally, for the carSequencing dilemmas I was talking about, there was some
related to variable and value ordering. I believe carSeq.cpp already does this
ordering of variables, but carSeqMDD.cpp does not. The search proposed by the
papers was branching on individual settings of cars in a specific order (so for
example, if we have 100 cars and 5 settings, the order would end up something
like ~car50option3, car51option3, car49option3... car100option3, car50option1...~
etc based on which option is seen as most restricted).

There was also some issue with the carSequencing implementation in C++ by
models. If you'd like, I can try to take a look at that in the next day or two
to refresh my memory about what was wrong in C++. The main takeaway was that one
group of constraints in the C++ implementation was iterating and using the wrong
values. It should be correct in obj-C, so you should be able to just compare
them one-to-one if you want to look at this yourself.

#+begin_src C++
  for(int o=0;o < nbO;o++) {
     for(int i=1;i < in.demand(o);i++) {
        int rLow = 0;
        int rUp = nbC - i * in.ub(o) - 1;
        auto sl = slice<var<bool>::Ptr>(rLow,rUp,[&setup,o](int s) { return setup[s][o];});
        cp->post(sum(sl) >= in.demand(o) - i * in.lb(o));
     }
   }
#+end_src

** This is the Swift code

#+begin_src c
  var demandForOption = 0
     for conf in 0 ..< carI.nbConf {
           if require[conf][o] == 1 {
                 demandForOption += Int(demand[conf])
              }
        }
     for i in 0 ... (demandForOption/carI.lb[o]) {
        let SR = range(m,low:0 ,up:cars.count - Int(i) * carI.ub[o] - 1)
           m.add(sum(m, R: SR) { s in setup[ORInt(o),s]} â‰¥ demandForOption - i * carI.lb[o])
     }
#+end_src
   
Let me know if you have any questions about any of this and I can try to provide
additional clarity.
